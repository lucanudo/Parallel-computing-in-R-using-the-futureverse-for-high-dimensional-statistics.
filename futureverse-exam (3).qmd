---
title: "Parallel computing with R using the futureverse"
subtitle: "Final Exam"
author: "Nudo Luca"
date: 22/10/2025
format:
    html:
        self-contained: true
---

::: {.callout-tip title="Instructions"}
For the first five questions, provide concise answers. For the coding questions, provide the R code in code blocks as follows:

```{r}
# Your R code here
```

along with any necessary explanations. 
:::

1. Explain the concept of *futures* in R. What are the core concepts? How does it help in parallel computing?
A future in R represents a value that may be available at a later time. The {future} framework abstracts parallel or distributed computations by letting users specify what to compute rather than how or where.
Future: A place for a value that will be computed later.
Plan: Defines where and how futures are evaluated as sequential, multisession and other options that you can choose.



2. How can you use the {future} package to differ computations to another R session? Provide a simple example.
```{r}
library(future)

# set multisession
plan(multisession, workers= 2)

#function
f <- future({
  Sys.sleep(2)
  median(rnorm(10000))
})

#call value
value(f)
```
  The computation of median(rnorm(10000)) is sent to another R session, and the main session remains responsive until value(f) retrieves the result.


3. Which package of the futureverse brings support for progress bars in parallel computations?
The package of futurverse that brings support for progress bars is 
```{r}
library(progressr)
```


4. Which functions in {future} are meant for users and which are meant for developers? Why is this distinction important?

The functions used for users are: future(), value(), plan()...
instead the functions used for developers: Future class, ResolvedFuture 

The functions used by users provide a clear and specific interface for parallelization, while developer functions define new backends or extend the framework safely without breaking abstraction.

5. Explain the difference between {future.apply} and {furrr}. When would you use one over the other?

{future.apply} provides parallelized versions of base apply() functions,
{furrr} provides parallelized versions of {purrr} in which are presents functions as future_map, future_map_dbl...

Use {future.apply} when working with base loops.
Use {furrr} when working with list-columns or pipelines.


6. Create a function that takes a data matrix with $n$ rows and $p$ columns and computes the following statistic:

$$
T_1 = \overline X^\top S^{+} \overline X,
$$

where

- $\overline X$ is the vector of column means;
- $S^{+}$ is the Moore-Penrose pseudoinverse of the sample covariance matrix:

$$
S^+ = \sum_{i=1}^{n-1} \lambda_i^{-1} u_i u_i^\top,
$$

where $\lambda_i$ and $u_i$ are the non-zero eigenvalues and corresponding eigenvectors of the sample covariance matrix.

*Hints:* 

- You can use `colMeans()` to compute the vector of column means.
- You can compute the sample covariance matrix with `cov()`.
- You can transpose a vector or a matrix with `t()`.
- You can use the matrix multiplication operator `%*%` to compute the product of two matrices.
- You can compute the eigen decomposition of a symmetric matrix with `eigen(M, symmetric = TRUE)`.


```{r}
T_1 <- function(X) {
  
  #Column means
  
  x_bar <- as.matrix(colMeans(X), ncol = 1)   
  
  #Sample covariance matrix
  
  S <- cov(X)
  
  #Eigen decomposition
  
  eig <- eigen(S, symmetric = TRUE)
  
  #Keep non-zero eigenvalues
  
  non_zero <- eig$values > 1e-10
  lambda_inv <- 1 / eig$values[non_zero]
  U <- eig$vectors[, non_zero, drop = FALSE]
  
  #Moore-Penrose pseudoinverse
  
  S_plus <- U %*% (diag(lambda_inv, nrow = length(lambda_inv))) %*% t(U)
  
  as.numeric(t(x_bar) %*% S_plus %*% x_bar)
}


```


7. Create another function that computes the following statistic:

$$
T_2 = \overline X^\top S_\alpha^{-1} \overline X,
$$

where $S_\alpha$ is the shrinkage estimator of the covariance matrix defined as:

$$
S_\alpha = (1 - \alpha) S + \alpha I,
$$

where $\alpha \in [0, 1]$ is the shrinkage intensity (you can set $\alpha = 0.1$) and $I$ is the identity matrix.

*Hints:*

- You can use `solve()` to compute the inverse of a matrix.
- You can use `diag(p)` to create a $p \times p$ identity matrix.

```{r}
T_2 <- function(X, alpha = 0.1) {
  x_bar <- as.matrix(colMeans(X), ncol = 1)   
  S <- cov(X)
  p <- ncol(S)                                
  
  # Shrinkage covariance estimator
  S_alpha <- (1 - alpha) * S + alpha * diag(p)
  
  # Ensure full-rank and correct dimensions
  S_alpha_inv <- solve(S_alpha)
  
  # Compute T2
  as.numeric(t(x_bar) %*% S_alpha_inv %*% x_bar)
}

```


8. Benchmark the functions with a matrix of $n = 500$ rows and $p = 1000$ columns filled with random normal numbers. Use **microbenchmark** package to understand the performance.

```{r}
library(microbenchmark)

set.seed(123)

n <- 500
p <- 1000
X <- matrix(rnorm(n * p), n, p)

#Benchmark
microbenchmark(
  T1 = T_1(X),
  T2 = T_2(X),
  times = 5
)
```



9. Generate a list of $B = 1000$ matrices with $n = 500$ rows and $p = 1000$ columns filled with random normal numbers and compute the statistics for each matrix in parallel using **furrr**. Visualize the distributions of the above statistic using a histogram.


```{r}
library(furrr)
library(ggplot2)
library(tidyverse)

# Set up
set.seed(123)
mat_list <- replicate(1000, matrix(rnorm(500 * 1000), 500, 1000), simplify = FALSE)

plan(multisession, workers = 4)

# result T_1
set.seed(123)
risultato1 <- future_map_dbl(mat_list, T_1)

# result T_2
set.seed(123)
risultato2 <- future_map_dbl(mat_list, T_2)

# results
results <- tibble(
  T1 = risultato1,
  T2 = risultato2
) %>%
  pivot_longer(cols = everything(), names_to = "stat", values_to = "value")

# histogram
ggplot(results, aes(x = value, fill = stat)) +
  geom_histogram(alpha = 0.6, bins = 30, position = "identity") +
  theme_minimal() +
  labs(
    title = "Distribution of T₁ and T₂ Statistics",
    x = "Value",
    y = "Frequency"
  )

```

This code runs 1000 independent computations in parallel using {furrr} and visualizes the distributions of the computed statistics 

::: {.callout-tip title="Instructions"}
For the first five questions, provide concise answers. For the coding questions, provide the R code in code blocks as follows:
  
  